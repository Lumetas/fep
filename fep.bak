#!/bin/bash

# Fancy Editor Plus (FEP) - оптимизированный текстовый редактор
# Автор: Ассистент с любовью ♥

# Конфигурация
readonly CONFIG_DIR="$HOME/.config/fep"
readonly CONFIG_FILES=("start" "startiter" "enditer" "premain")

# Цвета и стили
readonly BOLD='\033[1m'
readonly DIM='\033[2m'
readonly ITALIC='\033[3m'
readonly UNDERLINE='\033[4m'
readonly BLINK='\033[5m'
readonly REVERSE='\033[7m'
readonly HIDDEN='\033[8m'

# Цвета текста
readonly BLACK='\033[30m'
readonly RED='\033[31m'
readonly GREEN='\033[32m'
readonly YELLOW='\033[33m'
readonly BLUE='\033[34m'
readonly MAGENTA='\033[35m'
readonly CYAN='\033[36m'
readonly WHITE='\033[37m'

# Фоновые цвета
readonly BG_BLACK='\033[40m'
readonly BG_RED='\033[41m'
readonly BG_GREEN='\033[42m'
readonly BG_YELLOW='\033[43m'
readonly BG_BLUE='\033[44m'
readonly BG_MAGENTA='\033[45m'
readonly BG_CYAN='\033[46m'
readonly BG_WHITE='\033[47m'

# Сброс стилей
readonly RESET='\033[0m'

# Символы для красивого интерфейса
readonly CORNER_TL='┌'
readonly CORNER_TR='┐'
readonly CORNER_BL='└'
readonly CORNER_BR='┘'
readonly H_LINE='─'
readonly V_LINE='│'
readonly T_LEFT='┤'
readonly T_RIGHT='├'
readonly T_TOP='┴'
readonly T_BOTTOM='┬'
readonly CROSS='┼'

# Символы курсора
readonly CURSOR_BLOCK='\033[7m█\033[0m'
readonly CURSOR_UNDERLINE='\033[4m \033[0m'
readonly CURSOR_BEAM='\033[2m|\033[0m'

# Глобальные переменные
declare -a content
declare -i line_count=0 cursor_x=0 cursor_y=0 start_line=0
declare file="" original_file="" current_mode="normal"
declare -i visual_start_x=0 visual_start_y=0 visual_end_x=0 visual_end_y=0
declare -i screen_lines=0 screen_cols=0 modified=0

# ===== УТИЛИТЫ =====

# Логгирование
log() {
    echo "[FEP] $*" >> /tmp/fep.log
}

# Проверка существования команды
command_exists() {
    command -v "$1" &> /dev/null
}

# Получить размер терминала
get_terminal_size() {
    screen_lines=$(tput lines)
    screen_cols=$(tput cols)
}

# Загрузка конфигурации
load_config() {
    local config_file="$1"
    if [[ -f "$config_file" ]]; then
        source "$config_file" 2>/dev/null
    fi
}

# Инициализация конфигурации
init_config() {
    mkdir -p "$CONFIG_DIR"
    for config in "${CONFIG_FILES[@]}"; do
        touch "$CONFIG_DIR/$config"
    done
}

# ===== ФАЙЛОВЫЕ ОПЕРАЦИИ =====

# Загрузка файла
load_file() {
    local filename="$1"
    if [[ -f "$filename" && -r "$filename" ]]; then
        mapfile -t content < "$filename"
        line_count=${#content[@]}
        modified=0
        return 0
    else
        content=("")
        line_count=1
        return 1
    fi
}

# Сохранение файла
save_file() {
    local filename="$1"
    printf "%s\n" "${content[@]}" > "$filename"
    if [[ $? -eq 0 ]]; then
        modified=0
        return 0
    else
        return 1
    fi
}

# Создание резервной копии
create_backup() {
    local filename="$1"
    if [[ -f "$filename" ]]; then
        cp "$filename" "${filename}.bak"
    fi
}

# ===== ОПЕРАЦИИ С ТЕКСТОМ =====

# Получить текущую строку
get_current_line() {
    if [[ $cursor_y -lt $line_count ]]; then
        echo "${content[$cursor_y]}"
    else
        echo ""
    fi
}

# Установить текущую строку
set_current_line() {
    local new_line="$1"
    if [[ $cursor_y -lt $line_count ]]; then
        content[$cursor_y]="$new_line"
        modified=1
    fi
}

# Вставить строку
insert_line() {
    local position="$1" new_line="$2"
    if [[ $position -le $line_count ]]; then
        content=("${content[@]:0:$position}" "$new_line" "${content[@]:$position}")
        ((line_count++))
        modified=1
    fi
}

# Удалить строку
delete_line() {
    local position="$1"
    if [[ $position -lt $line_count ]]; then
        content=("${content[@]:0:$position}" "${content[@]:$((position + 1))}")
        ((line_count--))
        modified=1
        
        # Корректируем позицию курсора
        if [[ $cursor_y -ge $line_count && $line_count -gt 0 ]]; then
            cursor_y=$((line_count - 1))
        fi
    fi
}

# Вставить символ
insert_char() {
    local char="$1"
    local current_line=$(get_current_line)
    local new_line="${current_line:0:$cursor_x}$char${current_line:$cursor_x}"
    set_current_line "$new_line"
    ((cursor_x++))
}

# Удалить символ (backspace)
delete_char_backward() {
    local current_line=$(get_current_line)
    if [[ $cursor_x -gt 0 ]]; then
        local new_line="${current_line:0:$((cursor_x - 1))}${current_line:$cursor_x}"
        set_current_line "$new_line"
        ((cursor_x--))
    elif [[ $cursor_y -gt 0 ]]; then
        # Объединяем с предыдущей строкой
        local prev_line="${content[$((cursor_y - 1))]}"
        local new_line="$prev_line$current_line"
        content[$((cursor_y - 1))]="$new_line"
        delete_line "$cursor_y"
        cursor_y=$((cursor_y - 1))
        cursor_x=${#prev_line}
    fi
}

# Удалить символ (delete)
delete_char_forward() {
    local current_line=$(get_current_line)
    if [[ $cursor_x -lt ${#current_line} ]]; then
        local new_line="${current_line:0:$cursor_x}${current_line:$((cursor_x + 1))}"
        set_current_line "$new_line"
    elif [[ $cursor_y -lt $((line_count - 1)) ]]; then
        # Объединяем со следующей строкой
        local next_line="${content[$((cursor_y + 1))]}"
        local new_line="$current_line$next_line"
        set_current_line "$new_line"
        delete_line "$((cursor_y + 1))"
    fi
}

# Разделить строку (Enter)
split_line() {
    local current_line=$(get_current_line)
    local first_part="${current_line:0:$cursor_x}"
    local second_part="${current_line:$cursor_x}"
    
    set_current_line "$first_part"
    insert_line $((cursor_y + 1)) "$second_part"
    
    cursor_y=$((cursor_y + 1))
    cursor_x=0
}

# ===== КУРСОР И НАВИГАЦИЯ =====

# Красивый курсор
render_cursor() {
    local line="$1"
    local pos="$2"
    
    if [[ $pos -le ${#line} ]]; then
        if [[ $pos -eq ${#line} ]]; then
            # Курсор в конце строки
            echo -e "${line}${BLINK}${REVERSE} ${RESET}"
        else
            local char="${line:$pos:1}"
            local before="${line:0:$pos}"
            local after="${line:$((pos + 1))}"
            echo -e "${before}${BLINK}${REVERSE}${char}${RESET}${after}"
        fi
    else
        echo "$line"
    fi
}

# Подсветка выделения
render_selection() {
    local line="$1" line_num="$2"
    local start_y=$3 start_x=$4 end_y=$5 end_x=$6
    
    # Нормализуем координаты
    if [[ $start_y -gt $end_y ]]; then
        local temp_y=$start_y temp_x=$start_x
        start_y=$end_y start_x=$end_x
        end_y=$temp_y end_x=$temp_x
    elif [[ $start_y -eq $end_y && $start_x -gt $end_x ]]; then
        local temp_x=$start_x
        start_x=$end_x
        end_x=$temp_x
    fi
    
    # Проверяем, попадает ли строка в выделение
    if [[ $line_num -lt $start_y || $line_num -gt $end_y ]]; then
        echo "$line"
        return
    fi
    
    # Полное выделение строки
    if [[ $line_num -gt $start_y && $line_num -lt $end_y ]]; then
        echo -e "${BG_BLUE}${line}${RESET}"
        return
    fi
    
    local result=""
    
    # Первая строка выделения
    if [[ $line_num -eq $start_y ]]; then
        if [[ $line_num -eq $end_y ]]; then
            # Выделение в одной строке
            result="${line:0:$start_x}${BG_BLUE}${line:$start_x:$((end_x - start_x))}${RESET}${line:$end_x}"
        else
            # Выделение до конца строки
            result="${line:0:$start_x}${BG_BLUE}${line:$start_x}${RESET}"
        fi
    # Последняя строка выделения
    elif [[ $line_num -eq $end_y ]]; then
        # Выделение от начала до end_x
        result="${BG_BLUE}${line:0:$end_x}${RESET}${line:$end_x}"
    fi
    
    echo -e "$result"
}

# Корректировка позиции курсора
clamp_cursor() {
    local current_line=$(get_current_line)
    local line_length=${#current_line}
    
    # Ограничиваем X координату
    if [[ $cursor_x -lt 0 ]]; then
        cursor_x=0
    elif [[ $cursor_x -gt $line_length ]]; then
        cursor_x=$line_length
    fi
    
    # Ограничиваем Y координату
    if [[ $cursor_y -lt 0 ]]; then
        cursor_y=0
    elif [[ $cursor_y -ge $line_count ]]; then
        cursor_y=$((line_count - 1))
        if [[ $cursor_y -lt 0 ]]; then
            cursor_y=0
        fi
    fi
    
    # Корректируем скроллинг
    if [[ $cursor_y -lt $start_line ]]; then
        start_line=$cursor_y
    elif [[ $cursor_y -ge $((start_line + screen_lines - 4)) ]]; then
        start_line=$((cursor_y - screen_lines + 5))
        if [[ $start_line -lt 0 ]]; then
            start_line=0
        fi
    fi
}

# Навигация
move_left() { ((cursor_x--)); clamp_cursor; }
move_right() { ((cursor_x++)); clamp_cursor; }
move_up() { ((cursor_y--)); clamp_cursor; }
move_down() { ((cursor_y++)); clamp_cursor; }

move_word_forward() {
    local current_line=$(get_current_line)
    local i=$cursor_x
    
    # Пропускаем пробелы
    while [[ $i -lt ${#current_line} && ${current_line:$i:1} =~ [[:space:]] ]]; do
        ((i++))
    done
    
    # Идем до следующего пробела
    while [[ $i -lt ${#current_line} && ! ${current_line:$i:1} =~ [[:space:]] ]]; do
        ((i++))
    done
    
    cursor_x=$i
    clamp_cursor
}

move_word_backward() {
    local current_line=$(get_current_line)
    local i=$((cursor_x - 1))
    
    # Пропускаем пробелы
    while [[ $i -ge 0 && ${current_line:$i:1} =~ [[:space:]] ]]; do
        ((i--))
    done
    
    # Идем до начала слова
    while [[ $i -ge 0 && ! ${current_line:$i:1} =~ [[:space:]] ]]; do
        ((i--))
    done
    
    cursor_x=$((i + 1))
    clamp_cursor
}

move_line_begin() { cursor_x=0; clamp_cursor; }
move_line_end() { cursor_x=${#content[$cursor_y]}; clamp_cursor; }
move_file_begin() { cursor_y=0; cursor_x=0; start_line=0; }
move_file_end() { 
    cursor_y=$((line_count - 1)) 
    cursor_x=${#content[$cursor_y]}
    clamp_cursor
}

# ===== РЕЖИМЫ РЕДАКТИРОВАНИЯ =====

# Нормальный режим
normal_mode() {
    current_mode="normal"
}

# Режим вставки
insert_mode() {
    current_mode="insert"
    echo -ne "\033[6 q"  # Изменяем форму курсора в терминале
}

# Визуальный режим
visual_mode() {
    current_mode="visual"
    visual_start_x=$cursor_x
    visual_start_y=$cursor_y
    visual_end_x=$cursor_x
    visual_end_y=$cursor_y
}

# Командный режим
command_mode() {
    echo -ne "\033[2 q"  # Блочный курсор для командной строки
    echo -n ":"
    read -e cmd
    
    case "$cmd" in
        "q"|"quit")
            if [[ $modified -eq 1 ]]; then
                echo -n "Есть несохраненные изменения. Выйти anyway? (y/N): "
                read -n1 confirm
                if [[ $confirm != "y" && $confirm != "Y" ]]; then
                    return
                fi
            fi
            exit 0
            ;;
        "w"|"write")
            save_file "$original_file"
            show_message "Файл сохранен: $original_file"
            ;;
        "wq")
            save_file "$original_file"
            exit 0
            ;;
        "q!")
            exit 0
            ;;
        "e"*)
            local new_file="${cmd:2}"
            if [[ -n "$new_file" ]]; then
                load_file "$new_file" && original_file="$new_file"
            fi
            ;;
        "h")
            show_message "Помощь: i-вставка, v-визуальный, : - команды, Esc-нормальный"
            ;;
        "")
            ;;
        *)
            show_message "Неизвестная команда: $cmd"
            ;;
    esac
}

# ===== ОТОБРАЖЕНИЕ =====

# Показать сообщение
show_message() {
    local message="$1"
    echo -ne "\033[s"  # Сохраняем позицию курсора
    echo -ne "\033[$((screen_lines));1H"  # Переходим в последнюю строку
    echo -ne "\033[2K"  # Очищаем строку
    echo -ne "${BG_CYAN}${BLACK}${message}${RESET}"
    echo -ne "\033[u"  # Восстанавливаем позицию
}

# Отрисовка интерфейса
draw_interface() {
    clear
    get_terminal_size
    
    # Верхняя панель
    echo -ne "${BOLD}${CYAN}"
    echo -n "$CORNER_TL"
    printf "%*s" $((screen_cols - 2)) "" | tr ' ' "$H_LINE"
    echo -n "$CORNER_TR"
    echo -e "${RESET}"
    
    # Заголовок
    local title="Fancy Editor Plus"
    local file_info="Файл: ${original_file##*/}"
    local mode_info="Режим: $current_mode"
    local line_info="Строка: $((cursor_y + 1))/$line_count"
    local modified_flag=$([[ $modified -eq 1 ]] && echo " [+]")
    
    local info_line="$file_info$modified_flag | $mode_info | $line_info"
    local padding=$(( (screen_cols - ${#title} - ${#info_line} - 4) / 2 ))
    
    echo -ne "${CYAN}${V_LINE}${RESET}"
    printf "%*s" $padding ""
    echo -ne "${BOLD}${WHITE}$title${RESET}"
    printf "%*s" $padding ""
    echo -ne "${DIM}${WHITE}$info_line${RESET}"
    echo -e "${CYAN}${V_LINE}${RESET}"
    
    # Разделитель
    echo -ne "${CYAN}${V_LINE}${RESET}"
    echo -n "$T_RIGHT"
    printf "%*s" $((screen_cols - 4)) "" | tr ' ' "$H_LINE"
    echo -n "$T_LEFT"
    echo -e "${CYAN}${V_LINE}${RESET}"
    
    # Контент
    local content_height=$((screen_lines - 6))
    for ((i = start_line; i < start_line + content_height && i < line_count; i++)); do
        echo -ne "${CYAN}${V_LINE} ${RESET}"
        
        local line_number=$((i + 1))
        local line_content="${content[$i]}"
        
        # Номер строки
        echo -ne "${DIM}${BLUE}"
        printf "%4d " "$line_number"
        echo -ne "${RESET}"
        
        # Содержимое строки
        if [[ $current_mode == "visual" ]]; then
            line_content=$(render_selection "$line_content" "$i" "$visual_start_y" "$visual_start_x" "$visual_end_y" "$visual_end_x")
        fi
        
        if [[ $i -eq $cursor_y && $current_mode != "visual" ]]; then
            line_content=$(render_cursor "$line_content" "$cursor_x")
        fi
        
        echo -n "$line_content"
        
        # Заполнение пробелами до конца строки
        local content_length=$((6 + ${#content[$i]}))
        if [[ $content_length -lt $screen_cols ]]; then
            printf "%*s" $((screen_cols - content_length - 2)) ""
        fi
        
        echo -e "${CYAN} ${V_LINE}${RESET}"
    done
    
    # Заполнение пустых строк
    local displayed_lines=$((line_count - start_line))
    if [[ $displayed_lines -lt $content_height ]]; then
        for ((i = displayed_lines; i < content_height; i++)); do
            echo -ne "${CYAN}${V_LINE}${RESET}"
            printf "%*s" $((screen_cols - 2)) ""
            echo -e "${CYAN}${V_LINE}${RESET}"
        done
    fi
    
    # Нижняя панель
    echo -ne "${CYAN}${CORNER_BL}"
    printf "%*s" $((screen_cols - 2)) "" | tr ' ' "$H_LINE"
    echo -e "${CORNER_BR}${RESET}"
    
    # Статусная строка
    echo -ne "\033[$((screen_lines - 1));1H"
}

# ===== ОСНОВНОЙ ЦИКЛ =====

# Обработка ввода в нормальном режиме
handle_normal_input() {
    read -rsn1 key
    
    case "$key" in
        "h") move_left ;;
        "j") move_down ;;
        "k") move_up ;;
        "l") move_right ;;
        "w") move_word_forward ;;
        "b") move_word_backward ;;
        "0") move_line_begin ;;
        "$") move_line_end ;;
        "g") 
            read -rsn1 next_key
            if [[ $next_key == "g" ]]; then
                move_file_begin
            fi
            ;;
        "G") move_file_end ;;
        "i") insert_mode ;;
        "a") 
            move_right
            insert_mode
            ;;
        "I")
            move_line_begin
            insert_mode
            ;;
        "A")
            move_line_end
            insert_mode
            ;;
        "o")
            insert_line $((cursor_y + 1)) ""
            cursor_y=$((cursor_y + 1))
            cursor_x=0
            insert_mode
            ;;
        "O")
            insert_line $cursor_y ""
            cursor_x=0
            insert_mode
            ;;
        "x")
            delete_char_forward
            ;;
        "X")
            delete_char_backward
            ;;
        "d")
            read -rsn1 next_key
            if [[ $next_key == "d" ]]; then
                delete_line $cursor_y
            fi
            ;;
        "v") visual_mode ;;
        ":") command_mode ;;
        $'\e') ;;  # Escape
        "") ;;     # Enter
        *) show_message "Неизвестная команда: $key" ;;
    esac
}

# Обработка ввода в режиме вставки
handle_insert_input() {
    local old_stty
    old_stty=$(stty -g)
    stty -echo -icanon
    
    while [[ $current_mode == "insert" ]]; do
        read -rsn1 char
        
        case "$char" in
            $'\e')  # Escape
                normal_mode
                break
                ;;
            $'\x7f')  # Backspace
                delete_char_backward
                draw_interface
                ;;
            $'\r')  # Enter
                split_line
                draw_interface
                ;;
            $'\t')  # Tab
                insert_char "    "
                draw_interface
                ;;
            *)
                if [[ -n "$char" ]]; then
                    insert_char "$char"
                    draw_interface
                fi
                ;;
        esac
    done
    
    stty "$old_stty"
}

# Обработка ввода в визуальном режиме
handle_visual_input() {
    while [[ $current_mode == "visual" ]]; do
        draw_interface
        read -rsn1 key
        
        case "$key" in
            "h") move_left ;;
            "j") move_down ;;
            "k") move_up ;;
            "l") move_right ;;
            $'\e')  # Escape
                normal_mode
                ;;
            "y")  # Yank (copy)
                # Здесь можно добавить копирование в буфер
                show_message "Выделение скопировано"
                normal_mode
                ;;
            "d")  # Delete
                # Здесь можно добавить удаление выделения
                show_message "Выделение удалено"
                normal_mode
                ;;
        esac
        
        visual_end_x=$cursor_x
        visual_end_y=$cursor_y
        clamp_cursor
    done
}

# Основной цикл редактора
main_loop() {
    while true; do
        draw_interface
        
        case $current_mode in
            "normal") handle_normal_input ;;
            "insert") handle_insert_input ;;
            "visual") handle_visual_input ;;
        esac
    done
}

# Инициализация редактора
init_editor() {
    # Проверяем терминал
    if [[ ! -t 0 ]]; then
        echo "Ошибка: stdin не является терминалом"
        exit 1
    fi
    
    # Настройка терминала
    trap 'echo -ne "\033[2 q"; stty echo' EXIT INT TERM
    stty -echo -icanon
    
    # Инициализация
    get_terminal_size
    init_config
    load_config "$CONFIG_DIR/start"
    
    # Загрузка файла
    original_file="$1"
    if ! load_file "$original_file"; then
        echo -n "Файл '$original_file' не существует. Создать? (y/N): "
        read -n1 create
        if [[ $create == "y" || $create == "Y" ]]; then
            save_file "$original_file"
            load_file "$original_file"
        else
            exit 0
        fi
    fi
    
    # Создаем резервную копию
    create_backup "$original_file"
    
    # Устанавливаем начальные позиции
    cursor_x=0
    cursor_y=0
    start_line=0
    normal_mode
}

# Главная функция
main() {
    if [[ $# -ne 1 ]]; then
        echo "Использование: $0 <filename>"
        echo "Пример: $0 example.txt"
        exit 1
    fi
    
    init_editor "$1"
    main_loop
}

# Запуск
main "$@"
