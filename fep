#!/bin/bash
# Функция для открытия файла
# BACKPATH=$PATH;
# PATH="";
file_to_include="$HOME/.config/fep/start";
if [[ -f "$file_to_include" ]]; then
    source "$file_to_include";
fi

insertx=0;
inserty=0;

highlight_char() {
    local index="$1"  # Индекс символа, который нужно окрасить
    shift             # Сдвиг аргументов, остальные будут строкой

    # Объединяем оставшиеся аргументы в одну строку
    local string="$*"

    # Проверяем, что индекс не выходит за пределы строки
    if [ "$index" -gt "${#string}" ] || [ "$index" -lt 0 ]; then
        echo "Индекс $index вне диапазона строки."
        return
    fi

    # Проверка на случай выхода за пределы строки на 1
    if [ "$index" -eq "${#string}" ]; then
        local red_square='■'  # Символ квадрат 
        local red='\033[0;31m'
        local reset='\033[0m'
        echo -e "${string}${red}${red_square}${reset}"
        return
    fi

    # Получаем символ по указанному индексу
    local char_to_highlight="${string:$index:1}"

    # Проверяем, является ли символ пробелом
    if [ "$char_to_highlight" == " " ]; then
        char_to_highlight='■'  # Заменяем пробел на квадрат
    fi

    # Цвет для красного
    local red='\033[0;31m'
    local reset='\033[0m'

    # Собираем строку с окрашенным символом
    local highlighted_string="${string:0:index}${red}${char_to_highlight}${reset}${string:index+1}"

    # Выводим результат
    echo -e "$highlighted_string"
}


delete_lines() {
    local file="$1"
    local range="$2"

    # Проверка существования файла
    if [[ ! -f "$file" ]]; then
        echo "Файл не найден: $file"
        return 1
    fi

    # Обработка диапазона
    if [[ "$range" =~ ^[0-9]+$ ]]; then
        # Формат: X
        sed -i.bak "${range}d" "$file"
    elif [[ "$range" =~ ^([0-9]+)\.\.([0-9]+)$ ]]; then
        # Формат: X..Y
        start="${BASH_REMATCH[1]}"
        end="${BASH_REMATCH[2]}"
        sed -i.bak "${start},${end}d" "$file"
    else
        echo "Неверный формат диапазона: $range"
        return 1
    fi

}

function edit_range {
    local range=$1
    local file=$2
    local replace_mode=$3

    if [[ $range =~ ^([0-9]+)\.$ ]]; then
        # Формат "X." - вставка многострочного текста после строки X
        local line_number=${BASH_REMATCH[1]}
        # echo "Введите многострочный текст (Ctrl+D для окончания ввода):"
        new_text=$(cat)  # Читаем весь ввод до Ctrl+D

        # Вставляем все строки по отдельности
        IFS=$'\n'       # Задаем разделитель как новая строка
        for line in $new_text; do
            sed -i "${line_number}a $line" "$file"
            line_number=$((line_number + 1))  # Увеличиваем номер строки для добавления
        done

    elif [[ $range =~ ^([0-9]+)\.\.$ ]]; then
        # Формат "X.." - вставка многострочного текста перед строкой X
        local start=${BASH_REMATCH[1]}
        # echo "Введите многострочный текст (Ctrl+D для окончания ввода):"
        new_text=$(cat)  # Читаем весь ввод до Ctrl+D 

        if [[ $replace_mode == true ]]; then
            # Вставляем все строки по отдельности
            IFS=$'\n'       # Задаем разделитель как новая строка
            for line in $new_text; do
                sed -i "${start}i $line" "$file"
                start=$((start + 1))  # Увеличиваем номер строки для добавления
            done
        else
            # echo "Текущая строка ${start}: $(sed -n "${start}p" "$file")"
      echo;
        fi

    elif [[ $range =~ ^([0-9]+)\.\.([0-9]+)$ ]]; then
        # Формат "X..Y" - удаляем строки от X до Y и вставляем многострочный текст
        local start=${BASH_REMATCH[1]}
        local end=${BASH_REMATCH[2]}

        if [[ -f $file ]]; then
            if [[ $replace_mode == true ]]; then
                # echo "Введите многострочный текст (Ctrl+D для окончания ввода):"
                new_text=$(cat)  # Читаем весь ввод до Ctrl+D

                # Удаляем строки от start до end
                sed -i "${start},${end}d" "$file"

                # Вставляем новый текст на место удаленных строк
                IFS=$'\n'       # Задаем разделитель как новая строка
                for line in $new_text; do
                    sed -i "${start}i $line" "$file"
                    start=$((start + 1))  # Увеличиваем номер строки для добавления
                done

                # echo "Строки от $start до $end удалены, и новый текст вставлен."
            else
                # Вывод строк от start до end
                sed -n "${start},${end}p" "$file"  # Выводим строки от start до end
            fi
        else
            echo "Файл '$file' не найден."
        fi

    elif [[ $range =~ ^[0-9]+$ ]]; then
        # Простое число - замена строки
        local line_number=$range
        # echo "Введите новый текст (для замены строки):"
        new_text=$(cat)   # Читаем весь ввод до Ctrl+D
        
        # Для замены строки используем здесь c вместо s
        # и обрабатываем многострочный текст по строкам
        IFS=$'\n'
        tmp_file=$(mktemp)  # Создаем временный файл
        {
            # Сначала выводим строки до нужной
            sed -n "1,$((line_number - 1))p" "$file"
            # Выводим новый текст

            echo "$new_text"
            # Затем выводим остальные строки
            sed -n "$((line_number + 1)),\$p" "$file"
        } > "$tmp_file"

        # Заменяем оригинальный файл временным
        mv "$tmp_file" "$file"

    else
        echo "Некорректный формат диапазона."
    fi
}

openFile() {
    if [[ ! -f "$1" ]]; then
		echo "Файл не найден. Создать?(y)";
		read -rsn1 input;
		if [[ $input == y ]]; then
			touch $1;
		else
			return 1
		fi
    fi
    mapfile -t content < "$1"  # Читаем файл в массив
    return 0
}

search() {
  read;
  string=$(grep -n "$REPLY" $1 | head -n 1 | cut -d: -f1); 
    echo $(( $string - 1 ));
}

# Основной текстовый редактор
main() {
    openFile "$1" || return  # Открываем файл
    lineCount=${#content[@]}
    startLine=0
    linesPerPage=$(( $(tput lines) - 2 ))  # Количество строк, выводимых за раз
  



  
    while true; do

		file_to_include="$HOME/.config/fep/startiter";
		if [[ -f "$file_to_include" ]]; then
			source "$file_to_include";
		fi
        # Очистка терминала
        clear # Вывод строк

		current_string="${content[inserty]}";
		current_string_length=${#current_string};
		
		if [[ $current_string_length -lt $insertx ]]; then insertx=$current_string_length; fi

        for ((i = startLine; i < startLine + linesPerPage && i < lineCount; i++)); do
			if [[ $i == $inserty ]]; then echo "$(( $i + 1 )): $(highlight_char $insertx ${content[i]})";
			else echo "$(( $i + 1 )): ${content[i]}"; fi

      linesPerPage=$(( $(tput lines) - 2 ))
        done
        
        # Управление
        read -rsn1 input  # Ожидание ввода одного символа

        # Обработка ввода




		file_to_include="$HOME/.config/fep/enditer";
		if [[ -f "$file_to_include" ]]; then
		    source "$file_to_include";
		fi


		if [[ "$input" == "q" ]]; then break; fi
		if [[ "$input" == "J" ]]; then ((startLine++)) && ((startLine >= lineCount)) && startLine=$((lineCount - 1)); fi 
		if [[ "$input" == "K" ]]; then ((startLine--)) && ((startLine < 0)) && startLine=0; fi 
		if [[ "$input" == ":" ]]; then commandMode; fi 
		if [[ "$input" == "/" ]]; then startLine=$(search "$1"); fi 
		if [[ "$input" == "e" ]]; then edit $1 $startLine && lineCount=${#content[@]}; fi 
		if [[ "$input" == "d" ]]; then del $1 && lineCount=${#content[@]}; fi 
		if [[ $input == h ]]; then if [[ $insertx != 0 ]]; then insertx=$(($insertx - 1)); fi; fi
		if [[ $input == l ]]; then if [[ $current_string_length -gt $insertx ]]; then insertx=$(($insertx + 1)); fi; fi
		if [[ $input == j ]]; then inserty=$(($inserty + 1)); fi
		if [[ $input == k ]]; then inserty=$(($inserty - 1)); fi


    done
}


del () {
read;
delete_lines $1 $REPLY;
openFile $1;
}

edit() {
  read;
  range=$REPLY;
  clear;
  edit_range $REPLY $1 true;
  openFile $1;
  
}

commandMode() {
read;
$REPLY;
sleep 1;
}

# Проверка аргументов командной строки
if [[ $# -lt 1 ]]; then
    echo "Использование: $0 <имя_файла>"
    exit 1
fi


# Запуск редактора с указанным файлом

file_to_include="$HOME/.config/fep/premain";
if [[ -f "$file_to_include" ]]; then
    source "$file_to_include";
fi
main "$1"


