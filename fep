#!/bin/bash

# Конфигурационные файлы
CONFIG_DIR="$HOME/.config/fep"
START_CONFIG="$CONFIG_DIR/start"
START_ITER_CONFIG="$CONFIG_DIR/startiter"
END_ITER_CONFIG="$CONFIG_DIR/enditer"
PREMAIN_CONFIG="$CONFIG_DIR/premain"

# Глобальные переменные
file=""
declare -a content
declare -a original_content
lineCount=0
insertx=0
inserty=0
startLine=0
linesPerPage=0
norewrite=0
current_string=""
current_string_length=0
original_file=""
modified=0

# Visual mode variables
visual_mode=0
visual_start_x=0
visual_start_y=0
visual_end_x=0
visual_end_y=0

# Undo/redo system
declare -a undo_stack
declare -a redo_stack
undo_index=0

# Структура для хранения состояний
save_state() {
    # Сохраняем текущее состояние в отдельный массив
    local state=()
    for ((i=0; i<lineCount; i++)); do
        state[i]="${content[i]}"
    done
    
    # Сохраняем состояние как строку с разделителем, который не встречается в тексте
    local serialized_state=""
    for ((i=0; i<lineCount; i++)); do
        # Экранируем символы перевода строки
        local line="${state[i]//$'\n'/\\n}"
        serialized_state+="$line"
        if [[ $i -lt $((lineCount-1)) ]]; then
            serialized_state+=$'\x1f'  # Используем Unit Separator как разделитель
        fi
    done
    
    undo_stack[undo_index]="$serialized_state"
    undo_index=$((undo_index + 1))
    
    # Ограничиваем размер стека undo
    if [[ ${#undo_stack[@]} -gt 100 ]]; then
        undo_stack=("${undo_stack[@]:1}")
        undo_index=$((undo_index - 1))
    fi
    
    # Очищаем стек redo при новом действии
    redo_stack=()
    modified=1
}

# Undo
undo() {
    if [[ $undo_index -gt 1 ]]; then
        # Сохраняем текущее состояние в redo
        local current_state=""
        for ((i=0; i<lineCount; i++)); do
            local line="${content[i]//$'\n'/\\n}"
            current_state+="$line"
            if [[ $i -lt $((lineCount-1)) ]]; then
                current_state+=$'\x1f'
            fi
        done
        redo_stack+=("$current_state")
        
        # Восстанавливаем предыдущее состояние
        undo_index=$((undo_index - 1))
        local previous_state="${undo_stack[undo_index-1]}"
        
        # Восстанавливаем содержимое
        content=()
        IFS=$'\x1f' read -r -a content <<< "$previous_state"
        lineCount=${#content[@]}
        
        # Восстанавливаем экранированные символы
        for ((i=0; i<lineCount; i++)); do
            content[i]="${content[i]//\\n/$'\n'}"
        done
        
        # Обновляем текущую позицию
        if [[ $lineCount -gt 0 ]]; then
            current_string="${content[inserty]}"
            current_string_length=${#current_string}
            if [[ $insertx -gt $current_string_length ]]; then
                insertx=$current_string_length
            fi
        else
            current_string=""
            current_string_length=0
            insertx=0
            inserty=0
        fi
        
        adjust_scroll_to_cursor
    fi
}

# Redo
redo() {
    if [[ ${#redo_stack[@]} -gt 0 ]]; then
        # Сохраняем текущее состояние в undo
        local current_state=""
        for ((i=0; i<lineCount; i++)); do
            local line="${content[i]//$'\n'/\\n}"
            current_state+="$line"
            if [[ $i -lt $((lineCount-1)) ]]; then
                current_state+=$'\x1f'
            fi
        done
        undo_stack[undo_index]="$current_state"
        undo_index=$((undo_index + 1))
        
        # Восстанавливаем состояние из redo
        local redo_state="${redo_stack[-1]}"
        unset 'redo_stack[${#redo_stack[@]}-1]'
        
        # Восстанавливаем содержимое
        content=()
        IFS=$'\x1f' read -r -a content <<< "$redo_state"
        lineCount=${#content[@]}
        
        # Восстанавливаем экранированные символы
        for ((i=0; i<lineCount; i++)); do
            content[i]="${content[i]//\\n/$'\n'}"
        done
        
        # Обновляем текущую позицию
        if [[ $lineCount -gt 0 ]]; then
            current_string="${content[inserty]}"
            current_string_length=${#current_string}
            if [[ $insertx -gt $current_string_length ]]; then
                insertx=$current_string_length
            fi
        else
            current_string=""
            current_string_length=0
            insertx=0
            inserty=0
        fi
        
        adjust_scroll_to_cursor
    fi
}

# Загрузка конфигурационных файлов
load_config() {
    local config_file="$1"
    if [[ -f "$config_file" ]]; then
        source "$config_file"
    fi
}

# Получение выделенного текста
get_selected_text() {
    local start_y=$1 start_x=$2 end_y=$3 end_x=$4
    local selected_text=""
    
    # Нормализуем координаты для правильного выделения
    local sel_start_y=$start_y
    local sel_start_x=$start_x
    local sel_end_y=$end_y
    local sel_end_x=$end_x
    
    if [[ $sel_start_y -gt $sel_end_y ]]; then
        # Меняем местами если начало после конца
        local temp_y=$sel_start_y
        sel_start_y=$sel_end_y
        sel_end_y=$temp_y
        local temp_x=$sel_start_x
        sel_start_x=$sel_end_x
        sel_end_x=$temp_x
    elif [[ $sel_start_y -eq $sel_end_y && $sel_start_x -gt $sel_end_x ]]; then
        # В одной строке, но начало после конца
        local temp_x=$sel_start_x
        sel_start_x=$sel_end_x
        sel_end_x=$temp_x
    fi
    
    if [[ $sel_start_y -eq $sel_end_y ]]; then
        # Выделение в одной строке
        local line="${content[sel_start_y]}"
        local start_pos=$sel_start_x
        local end_pos=$sel_end_x
        if [[ $start_pos -gt $end_pos ]]; then
            local temp=$start_pos
            start_pos=$end_pos
            end_pos=$temp
        fi
        selected_text="${line:start_pos:end_pos-start_pos}"
    else
        # Многострочное выделение
        # Первая строка
        local first_line="${content[sel_start_y]}"
        selected_text="${first_line:sel_start_x}"
        
        # Промежуточные строки
        for ((i = sel_start_y + 1; i < sel_end_y; i++)); do
            selected_text+=$'\n'"${content[i]}"
        done
        
        # Последняя строка
        local last_line="${content[sel_end_y]}"
        if [[ $sel_end_x -gt 0 ]]; then
            selected_text+=$'\n'"${last_line:0:sel_end_x}"
        fi
    fi
    
    echo "$selected_text"
}

# Удаление выделенного текста (в памяти)
delete_selected_text() {
    local start_y=$1 start_x=$2 end_y=$3 end_x=$4
    
    save_state
    
    # Нормализуем координаты для правильного удаления
    local del_start_y=$start_y
    local del_start_x=$start_x
    local del_end_y=$end_y
    local del_end_x=$end_x
    
    if [[ $del_start_y -gt $del_end_y ]]; then
        local temp_y=$del_start_y
        del_start_y=$del_end_y
        del_end_y=$temp_y
        local temp_x=$del_start_x
        del_start_x=$del_end_x
        del_end_x=$temp_x
    elif [[ $del_start_y -eq $del_end_y && $del_start_x -gt $del_end_x ]]; then
        local temp_x=$del_start_x
        del_start_x=$del_end_x
        del_end_x=$temp_x
    fi
    
    if [[ $del_start_y -eq $del_end_y ]]; then
        # Удаление в одной строке
        local line="${content[del_start_y]}"
        local start_pos=$del_start_x
        local end_pos=$del_end_x
        if [[ $start_pos -gt $end_pos ]]; then
            local temp=$start_pos
            start_pos=$end_pos
            end_pos=$temp
        fi
        
        # Создаем новую строку без выделенного фрагмента
        local new_line="${line:0:start_pos}${line:end_pos}"
        content[del_start_y]="$new_line"
        
    else
        # Многострочное удаление
        local new_content=()
        
        for ((i=0; i<lineCount; i++)); do
            if [[ $i -lt $del_start_y || $i -gt $del_end_y ]]; then
                # Строки до и после выделения
                new_content+=("${content[i]}")
            elif [[ $i -eq $del_start_y ]]; then
                # Первая строка выделения - обрезаем с конца
                local first_line="${content[i]}"
                new_content+=("${first_line:0:del_start_x}")
            elif [[ $i -eq $del_end_y ]]; then
                # Последняя строка выделения - обрезаем с начала
                local last_line="${content[i]}"
                if [[ $del_end_x -lt ${#last_line} ]]; then
                    new_content+=("${last_line:del_end_x}")
                fi
            fi
        done
        
        content=("${new_content[@]}")
        lineCount=${#content[@]}
    fi
    
    # Обновляем текущую позицию
    inserty=$del_start_y
    insertx=$del_start_x
    if [[ $lineCount -gt 0 ]]; then
        current_string="${content[inserty]}"
        current_string_length=${#current_string}
    else
        current_string=""
        current_string_length=0
    fi
}

# Замена строки (в памяти)
replace_line() {
    local line_number=$1
    local new_line=$2
    content[line_number]="$new_line"
}

# Вставка новой строки после указанной (в памяти)
insert_line_after() {
    local line_number=$1
    save_state
    
    local new_content=()
    for ((i=0; i<=line_number; i++)); do
        new_content+=("${content[i]}")
    done
    new_content+=("")
    for ((i=line_number+1; i<lineCount; i++)); do
        new_content+=("${content[i]}")
    done
    
    content=("${new_content[@]}")
    lineCount=${#content[@]}
}

# Вставка новой строки перед указанной (в памяти)
insert_line_before() {
    local line_number=$1
    save_state
    
    local new_content=()
    for ((i=0; i<line_number; i++)); do
        new_content+=("${content[i]}")
    done
    new_content+=("")
    for ((i=line_number; i<lineCount; i++)); do
        new_content+=("${content[i]}")
    done
    
    content=("${new_content[@]}")
    lineCount=${#content[@]}
}

# Удаление символа (в памяти)
remove_char() {
    local line_number="$1"
    local char_position="$2"
    
    save_state
    
    if [[ $line_number -lt 0 || $line_number -ge $lineCount ]]; then
        return 1
    fi
    
    local line="${content[line_number]}"
    if [[ $char_position -lt 0 || $char_position -ge ${#line} ]]; then
        return 1
    fi
    
    local modified_line="${line:0:char_position}${line:char_position+1}"
    content[line_number]="$modified_line"
    
    if [[ $line_number -eq $inserty ]]; then
        current_string="$modified_line"
        current_string_length=${#modified_line}
    fi
}

# Вставка символа (в памяти)
insert_char() {
    local new_char="$1"
    local line_number="$2"
    local char_position="$3"
    
    save_state
    
    if [[ $line_number -lt 0 || $line_number -ge $lineCount ]]; then
        return 1
    fi
    
    local line="${content[line_number]}"
    
    if [[ $char_position -lt 0 ]]; then
        return 1
    elif [[ $char_position -gt ${#line} ]]; then
        # Если позиция больше длины строки, добавляем пробелы и символ
        local padding=$((char_position - ${#line}))
        local modified_line="${line}$(printf '%*s' $padding '')${new_char}"
    else
        # Вставляем символ (не заменяем)
        local modified_line="${line:0:char_position}${new_char}${line:char_position}"
    fi
    
    content[line_number]="$modified_line"
    
    if [[ $line_number -eq $inserty ]]; then
        current_string="$modified_line"
        current_string_length=${#modified_line}
    fi
}

# Вставка новой строки (в памяти)
insert_newline() {
    local line_number="$1"
    local char_position="$2"
    
    save_state
    
    if [[ $line_number -lt 0 || $line_number -ge $lineCount ]]; then
        return 1
    fi
    
    local line="${content[line_number]}"
    local first_part="${line:0:char_position}"
    local second_part="${line:char_position}"
    
    local new_content=()
    for ((i=0; i<line_number; i++)); do
        new_content+=("${content[i]}")
    done
    new_content+=("$first_part")
    new_content+=("$second_part")
    for ((i=line_number+1; i<lineCount; i++)); do
        new_content+=("${content[i]}")
    done
    
    content=("${new_content[@]}")
    lineCount=${#content[@]}
}

# Удаление переноса строки (объединение с предыдущей строкой) (в памяти)
remove_newline() {
    local line_number="$1"
    
    save_state
    
    if [[ $line_number -lt 1 || $line_number -ge $lineCount ]]; then
        return 1
    fi
    
    local prev_line="${content[line_number-1]}"
    local current_line="${content[line_number]}"
    local merged_line="${prev_line}${current_line}"
    
    local new_content=()
    for ((i=0; i<line_number-1; i++)); do
        new_content+=("${content[i]}")
    done
    new_content+=("$merged_line")
    for ((i=line_number+1; i<lineCount; i++)); do
        new_content+=("${content[i]}")
    done
    
    content=("${new_content[@]}")
    lineCount=${#content[@]}
}

# Замена символа (в памяти)
replace_char_in_line() {
    local new_char="$1"
    local line_number="$2"
    local char_position="$3"
    
    save_state
    
    if [[ $line_number -lt 0 || $line_number -ge $lineCount ]]; then
        return 1
    fi
    
    local line="${content[line_number]}"
    local modified_line=""
    
    if [[ $char_position -ge ${#line} ]]; then
        modified_line="${line}${new_char}"
    elif [[ $char_position -lt 0 ]]; then
        return 1
    else
        modified_line="${line:0:char_position}${new_char}${line:char_position+1}"
    fi
    
    content[line_number]="$modified_line"
    
    if [[ $line_number -eq $inserty ]]; then
        current_string="$modified_line"
        current_string_length=${#modified_line}
    fi
}

# Подсветка символа под курсором
highlight_char() {
    local index="$1"
    shift
    local string="$*"

    if [ "$index" -lt 0 ]; then
        echo "Ошибка: индекс $index вне диапазона строки."
        return 1
    fi

    # Инверсный цвет (белая заливка) для курсора
    local invert='\033[7m'
    local reset='\033[0m'

    if [ "$index" -ge "${#string}" ]; then
        # Курсор в конце строки - показываем пробел с инверсным цветом
        echo -e "${string}${invert} ${reset}"
        return 0
    fi

    # Курсор на символе - инвертируем цвет символа
    local char_to_highlight="${string:$index:1}"
    local highlighted_string="${string:0:index}${invert}${char_to_highlight}${reset}${string:index+1}"
    echo -e "$highlighted_string"
}

# Подсветка выделенного текста
highlight_selection() {
    local line_number="$1"
    local string="$2"
    local start_y=$3 start_x=$4 end_y=$5 end_x=$6
    
    # Нормализуем координаты выделения
    local vis_start_y=$start_y
    local vis_start_x=$start_x
    local vis_end_y=$end_y
    local vis_end_x=$end_x
    
    if [[ $vis_start_y -gt $vis_end_y ]]; then
        local temp_y=$vis_start_y
        vis_start_y=$vis_end_y
        vis_end_y=$temp_y
        local temp_x=$vis_start_x
        vis_start_x=$vis_end_x
        vis_end_x=$temp_x
    elif [[ $vis_start_y -eq $vis_end_y && $vis_start_x -gt $vis_end_x ]]; then
        local temp_x=$vis_start_x
        vis_start_x=$vis_end_x
        vis_end_x=$temp_x
    fi
    
    # Цвета для выделения (синий фон)
    local highlight='\033[48;5;24m'
    local reset='\033[0m'
    
    # Если строка не входит в выделение
    if [[ $line_number -lt $vis_start_y || $line_number -gt $vis_end_y ]]; then
        echo "$string"
        return
    fi
    
    # Если вся строка выделена (промежуточные строки)
    if [[ $line_number -gt $vis_start_y && $line_number -lt $vis_end_y ]]; then
        echo -e "${highlight}${string}${reset}"
        return
    fi
    
    local result=""
    
    # Первая строка выделения
    if [[ $line_number -eq $vis_start_y ]]; then
        if [[ $line_number -eq $vis_end_y ]]; then
            # Выделение в пределах одной строки
            local left_part="${string:0:vis_start_x}"
            local middle_part="${string:vis_start_x:vis_end_x-vis_start_x}"
            local right_part="${string:vis_end_x}"
            result="${left_part}${highlight}${middle_part}${reset}${right_part}"
        else
            # Выделение от start_x до конца строки
            local left_part="${string:0:vis_start_x}"
            local right_part="${string:vis_start_x}"
            result="${left_part}${highlight}${right_part}${reset}"
        fi
    # Последняя строка выделения
    elif [[ $line_number -eq $vis_end_y ]]; then
        # Выделение от начала до end_x
        local left_part="${string:0:vis_end_x}"
        local right_part="${string:vis_end_x}"
        result="${highlight}${left_part}${reset}${right_part}"
    fi
    
    echo -e "$result"
}

# Удаление строк (в памяти)
delete_lines() {
    local range="$1"

    save_state

    # Обработка диапазона . (текущая строка)
    if [[ "$range" == "." ]]; then
        range="$((inserty + 1))"
    fi

    # Обработка диапазона + (следующая строка)
    if [[ "$range" == "+" ]]; then
        range="$((inserty + 2))"
    fi

    # Обработка диапазона - (предыдущая строка)
    if [[ "$range" == "-" ]]; then
        if [[ $inserty -gt 0 ]]; then
            range="$inserty"
        else
            echo "Ошибка: нет предыдущей строки для удаления"
            return 1
        fi
    fi

    local new_content=()
    
    if [[ "$range" =~ ^[0-9]+$ ]]; then
        # Удаление одной строки
        local line_to_delete=$((range - 1))
        for ((i=0; i<lineCount; i++)); do
            if [[ $i -ne $line_to_delete ]]; then
                new_content+=("${content[i]}")
            fi
        done
        
    elif [[ "$range" =~ ^([0-9]+)\.\.([0-9]+)$ ]]; then
        # Удаление диапазона строк
        local start=$((BASH_REMATCH[1] - 1))
        local end=$((BASH_REMATCH[2] - 1))
        
        for ((i=0; i<lineCount; i++)); do
            if [[ $i -lt $start || $i -gt $end ]]; then
                new_content+=("${content[i]}")
            fi
        done
    else
        echo "Ошибка: неверный формат диапазона: $range"
        return 1
    fi

    content=("${new_content[@]}")
    lineCount=${#content[@]}
    
    # Корректируем позицию курсора
    if [[ $inserty -ge $lineCount ]]; then
        inserty=$((lineCount - 1))
        if [[ $inserty -lt 0 ]]; then
            inserty=0
        fi
    fi
    
    if [[ $lineCount -gt 0 ]]; then
        current_string="${content[inserty]}"
        current_string_length=${#current_string}
        if [[ $insertx -gt $current_string_length ]]; then
            insertx=$current_string_length
        fi
    else
        current_string=""
        current_string_length=0
        insertx=0
    fi
}

# Открытие файла в память
openFile() {
    if [[ -f "$1" ]]; then
        mapfile -t content <"$1"
        mapfile -t original_content <"$1"
        lineCount=${#content[@]}
        
        # Сохраняем начальное состояние в undo stack
        undo_stack=()
        redo_stack=()
        undo_index=0
        save_state
        modified=0
    else
        content=()
        original_content=()
        lineCount=0
        undo_stack=()
        redo_stack=()
        undo_index=0
        modified=0
    fi
    return 0
}

# Сохранение файла из памяти
saveFile() {
    local save_file="$1"
    printf "%s\n" "${content[@]}" > "$save_file"
    if [[ $? -eq 0 ]]; then
        echo "Файл сохранен: $save_file"
        modified=0
        # Обновляем оригинальное содержимое
        mapfile -t original_content <"$save_file"
        return 0
    else
        echo "Ошибка: не удалось сохранить файл $save_file"
        return 1
    fi
}

# Перерисовка экрана
rewrite() {
    clear
    local status_line="Файл: $original_file | Строк: $lineCount | Курсор: ($insertx, $((inserty + 1)))"
    if [[ $insert_mode -eq 1 ]]; then
        status_line+=" | INSERT MODE"
    elif [[ $visual_mode -eq 1 ]]; then
        status_line+=" | VISUAL MODE"
	else 
		status_line+=" | NORMAL MODE"
    fi

    echo "$status_line"
    echo "---"

    if [[ $lineCount -gt 0 ]]; then
        current_string="${content[inserty]}"
        current_string_length=${#current_string}

        if [[ $current_string_length -lt $insertx ]]; then
            insertx=$current_string_length
        fi
    else
        current_string=""
        current_string_length=0
        insertx=0
    fi

    for ((i = startLine; i < startLine + linesPerPage && i < lineCount; i++)); do
        local display_line="${content[i]}"
        
        if [[ $visual_mode -eq 1 ]]; then
            # В visual mode подсвечиваем выделение
            display_line=$(highlight_selection "$i" "${content[i]}" "$visual_start_y" "$visual_start_x" "$visual_end_y" "$visual_end_x")
        fi
        
        if [[ $i -eq $inserty && $visual_mode -eq 0 ]]; then
            # В нормальном режиме показываем курсор белым прямоугольником
            echo "$(($i + 1)): $(highlight_char $insertx "${content[i]}")"
        else
            echo "$(($i + 1)): $display_line"
        fi
    done

    # Если файл пустой, показываем пустую строку с курсором
    if [[ $lineCount -eq 0 ]]; then
        echo "1: $(highlight_char $insertx "")"
    fi

    # Статусная строка
    echo "---"
    if [[ $visual_mode -eq 1 ]]; then
        # echo "VISUAL MODE: v - выход, d - удалить выделение, : - команда с выделенным текстом"
		echo;
    else
        # echo "u - отмена, Ctrl+r - повтор, : - команда, i - вставка, v - визуальный режим"
		echo;
    fi
}

# Создание новой строки если файл пустой
create_first_line_if_empty() {
    if [[ $lineCount -eq 0 ]]; then
        save_state
        content=("")
        lineCount=1
        current_string=""
        current_string_length=0
        insertx=0
        inserty=0
        return 0
    fi
    return 1
}

# Режим вставки
insertMode() {
	insert_mode=1
    local mode="$2"  # normal, begin, after, end
    
    # Создаем первую строку если файл пустой
    if [[ $lineCount -eq 0 ]]; then
        create_first_line_if_empty
    fi
    
    case "$mode" in
        "begin")
            insertx=0
            ;;
        "end")
            current_string="${content[inserty]}"
            insertx=${#current_string}
            ;;
        "after")
            if [[ $insertx -lt ${#current_string} ]]; then
                ((insertx++))
            fi
            ;;
    esac
    
    echo "--- Режим вставки (Esc для выхода) ---"
    
    # Сохраняем текущие настройки терминала
    local old_stty
    old_stty=$(stty -g)
    
    # Настраиваем терминал для raw ввода с поддержкой UTF-8
    stty -echo -icanon
    
    while true; do
        rewrite
        local input
        local char
        input=""
        
        # Чтение одного символа с поддержкой UTF-8
        char=$(dd bs=1 count=1 2>/dev/null)
        local exit_code=$?
        
        if [[ $exit_code -ne 0 ]]; then
			insert_mode=0
            break
        fi
        
        # Обработка Escape (начало escape-последовательности)
        if [[ "$char" == $'\e' ]]; then
            # Проверяем, не является ли это началом escape-последовательности
            sleep 0.01
            if read -t 0.1 -n 1 -r next_char; then
                # Это escape-последовательность, игнорируем
                continue
            else
                # Это одиночный Escape - выходим
				insert_mode=0
                break
            fi
        fi
        
        # Обработка Enter (новая строка)
        if [[ "$char" == $'\n' || "$char" == $'\r' ]]; then
            insert_newline "$inserty" "$insertx"
            ((inserty++))
            insertx=0
            continue
        fi
        
        # Обработка Backspace
        if [[ "$char" == $'\x7f' || "$char" == $'\x08' ]]; then
            if [[ $insertx -eq 0 && $inserty -gt 0 ]]; then
                # Объединяем с предыдущей строкой
                remove_newline "$inserty"
                ((inserty--))
                current_string="${content[inserty]}"
                insertx=${#current_string}
            elif [[ $insertx -gt 0 ]]; then
                # Обычное удаление символа
                remove_char "$inserty" $((insertx - 1))
                ((insertx--))
            fi
            continue
        fi
        
        # Обработка Tab
        if [[ "$char" == $'\t' ]]; then
            # Вставляем 4 пробела вместо таба
            insert_char " " "$inserty" "$insertx"
            ((insertx++))
            insert_char " " "$inserty" "$insertx"
            ((insertx++))
            insert_char " " "$inserty" "$insertx"
            ((insertx++))
            insert_char " " "$inserty" "$insertx"
            ((insertx++))
            continue
        fi
        
        # Обработка обычных символов (включая пробел и русские буквы)
        if [[ -n "$char" ]]; then
            insert_char "$char" "$inserty" "$insertx"
            ((insertx++))
        fi
    done
    
    # Восстанавливаем настройки терминала
    stty "$old_stty"
    
    echo "--- Выход из режима вставки ---"
}

# Режим удаления
removeModer() {
    if [[ $lineCount -gt 0 && $current_string_length -gt 0 && $insertx -lt $current_string_length ]]; then
        remove_char "$inserty" "$insertx"
        # Курсор остается на месте после удаления
        rewrite
    fi
}

# Поиск символа вперед (f)
find_char_forward() {
    if [[ $lineCount -eq 0 ]]; then
        return
    fi
    
    echo -n "Найти символ вперед: "
    read -rsn1 target_char
    echo
    
    current_string="${content[inserty]}"
    
    # Ищем символ в текущей строке после курсора
    for ((i = insertx + 1; i < ${#current_string}; i++)); do
        if [[ "${current_string:$i:1}" == "$target_char" ]]; then
            insertx=$i
            return
        fi
    done
    
    # Если не нашли в текущей строке, ищем в следующих строках
    for ((i = inserty + 1; i < lineCount; i++)); do
        current_string="${content[i]}"
        for ((j = 0; j < ${#current_string}; j++)); do
            if [[ "${current_string:$j:1}" == "$target_char" ]]; then
                inserty=$i
                insertx=$j
                adjust_scroll_to_cursor
                return
            fi
        done
    done
    
    echo "Символ '$target_char' не найден"
    sleep 1
}

# Поиск символа назад (F)
find_char_backward() {
    if [[ $lineCount -eq 0 ]]; then
        return
    fi
    
    echo -n "Найти символ назад: "
    read -rsn1 target_char
    echo
    
    # Ищем в текущей строке перед курсором
    current_string="${content[inserty]}"
    for ((i = insertx - 1; i >= 0; i--)); do
        if [[ "${current_string:$i:1}" == "$target_char" ]]; then
            insertx=$i
            return
        fi
    done
    
    # Если не нашли в текущей строке, ищем в предыдущих строках
    for ((i = inserty - 1; i >= 0; i--)); do
        current_string="${content[i]}"
        for ((j = ${#current_string} - 1; j >= 0; j--)); do
            if [[ "${current_string:$j:1}" == "$target_char" ]]; then
                inserty=$i
                insertx=$j
                adjust_scroll_to_cursor
                return
            fi
        done
    done
    
    echo "Символ '$target_char' не найден"
    sleep 1
}

# Поиск до символа вперед (t)
find_till_char_forward() {
    if [[ $lineCount -eq 0 ]]; then
        return
    fi
    
    echo -n "Найти до символа вперед: "
    read -rsn1 target_char
    echo
    
    current_string="${content[inserty]}"
    
    # Ищем символ в текущей строке после курсора
    for ((i = insertx + 1; i < ${#current_string}; i++)); do
        if [[ "${current_string:$i:1}" == "$target_char" ]]; then
            insertx=$((i - 1))
            return
        fi
    done
    
    # Если не нашли в текущей строке, ищем в следующих строках
    for ((i = inserty + 1; i < lineCount; i++)); do
        current_string="${content[i]}"
        for ((j = 0; j < ${#current_string}; j++)); do
            if [[ "${current_string:$j:1}" == "$target_char" ]]; then
                inserty=$i
                insertx=$((j - 1))
                if [[ $insertx -lt 0 ]]; then
                    insertx=0
                fi
                adjust_scroll_to_cursor
                return
            fi
        done
    done
    
    echo "Символ '$target_char' не найден"
    sleep 1
}

# Поиск до символа назад (T)
find_till_char_backward() {
    if [[ $lineCount -eq 0 ]]; then
        return
    fi
    
    echo -n "Найти до символа назад: "
    read -rsn1 target_char
    echo
    
    # Ищем в текущей строке перед курсором
    current_string="${content[inserty]}"
    for ((i = insertx - 1; i >= 0; i--)); do
        if [[ "${current_string:$i:1}" == "$target_char" ]]; then
            insertx=$((i + 1))
            return
        fi
    done
    
    # Если не нашли в текущей строке, ищем в предыдущих строках
    for ((i = inserty - 1; i >= 0; i--)); do
        current_string="${content[i]}"
        for ((j = ${#current_string} - 1; j >= 0; j--)); do
            if [[ "${current_string:$j:1}" == "$target_char" ]]; then
                inserty=$i
                insertx=$((j + 1))
                if [[ $insertx -ge ${#current_string} ]]; then
                    insertx=$((${#current_string} - 1))
                fi
                adjust_scroll_to_cursor
                return
            fi
        done
    done
    
    echo "Символ '$target_char' не найден"
    sleep 1
}

# Переход к строке по номеру
goto_line() {
    echo -n "Перейти к строке: "
    read line_number
    
    if [[ $line_number =~ ^[0-9]+$ ]]; then
        if [[ $line_number -ge 1 && $line_number -le $lineCount ]]; then
            inserty=$((line_number - 1))
            insertx=0
            adjust_scroll_to_cursor
        else
            echo "Некорректный номер строки"
            sleep 1
        fi
    else
        echo "Введите число"
        sleep 1
    fi
}

# Переход в конец файла
goto_end() {
    if [[ $lineCount -gt 0 ]]; then
        inserty=$((lineCount - 1))
        current_string="${content[inserty]}"
        insertx=${#current_string}
        adjust_scroll_to_cursor
    fi
}

# Корректировка скролла чтобы курсор был виден
adjust_scroll_to_cursor() {
    # Если курсор выше видимой области
    if [[ $inserty -lt $startLine ]]; then
        startLine=$inserty
    fi
    
    # Если курсор ниже видимой области
    if [[ $inserty -ge $((startLine + linesPerPage)) ]]; then
        startLine=$((inserty - linesPerPage + 1))
        if [[ $startLine -lt 0 ]]; then
            startLine=0
        fi
    fi
}

# Переход к следующему слову (w)
next_word() {
    if [[ $lineCount -eq 0 ]]; then
        return
    fi
    
    current_string="${content[inserty]}"
    local length=${#current_string}
    
    # Если мы в конце строки, переходим к следующей строке
    if [[ $insertx -ge $length ]]; then
        if [[ $inserty -lt $((lineCount - 1)) ]]; then
            ((inserty++))
            insertx=0
            adjust_scroll_to_cursor
        fi
        return
    fi
    
    # Пропускаем текущее слово (если мы на нем)
    local i=$insertx
    while [[ $i -lt $length && "${current_string:$i:1}" =~ [[:alnum:]_] ]]; do
        ((i++))
    done
    
    # Пропускаем пробелы/разделители
    while [[ $i -lt $length && ! "${current_string:$i:1}" =~ [[:alnum:]_] ]]; do
        ((i++))
    done
    
    # Если нашли начало следующего слова
    if [[ $i -lt $length ]]; then
        insertx=$i
    else
        # Переходим к следующей строке
        if [[ $inserty -lt $((lineCount - 1)) ]]; then
            ((inserty++))
            insertx=0
            adjust_scroll_to_cursor
        else
            # Если это последняя строка, переходим в конец
            insertx=$length
        fi
    fi
}

# Переход к предыдущему слову (b)
prev_word() {
    if [[ $lineCount -eq 0 ]]; then
        return
    fi
    
    current_string="${content[inserty]}"
    
    # Если мы в начале строки, переходим к предыдущей строке
    if [[ $insertx -eq 0 ]]; then
        if [[ $inserty -gt 0 ]]; then
            ((inserty--))
            current_string="${content[inserty]}"
            insertx=${#current_string}
            adjust_scroll_to_cursor
        fi
        return
    fi
    
    # Двигаемся назад через пробелы/разделители
    local i=$((insertx - 1))
    while [[ $i -gt 0 && ! "${current_string:$i:1}" =~ [[:alnum:]_] ]]; do
        ((i--))
    done
    
    # Двигаемся назад через слово
    while [[ $i -gt 0 && "${current_string:$i:1}" =~ [[:alnum:]_] ]]; do
        ((i--))
    done
    
    # Корректируем позицию
    if [[ $i -eq 0 && "${current_string:$i:1}" =~ [[:alnum:]_] ]]; then
        insertx=0
    else
        insertx=$((i + 1))
    fi
}

# Visual mode
visualMode() {
    visual_mode=1
    visual_start_x=$insertx
    visual_start_y=$inserty
    visual_end_x=$insertx
    visual_end_y=$inserty
    
    while [[ $visual_mode -eq 1 ]]; do
        rewrite
        
        read -rsn1 input
        
        case "$input" in
            "v")
                # Выход из visual mode
                visual_mode=0
                ;;
            "h")
                if [[ $visual_end_x -gt 0 ]]; then
                    ((visual_end_x--))
                elif [[ $visual_end_y -gt 0 ]]; then
                    # Переход на предыдущую строку
                    ((visual_end_y--))
                    visual_end_x=${#content[visual_end_y]}
                    if [[ $visual_end_x -lt 0 ]]; then
                        visual_end_x=0
                    fi
                fi
                ;;
            "l")
                if [[ $lineCount -gt 0 ]]; then
                    if [[ $visual_end_x -lt ${#content[visual_end_y]} ]]; then
                        ((visual_end_x++))
                    elif [[ $visual_end_y -lt $((lineCount - 1)) ]]; then
                        # Переход на следующую строку
                        ((visual_end_y++))
                        visual_end_x=0
                    fi
                fi
                ;;
            "j")
                if [[ $visual_end_y -lt $((lineCount - 1)) ]]; then
                    ((visual_end_y++))
                    if [[ $visual_end_x -gt ${#content[visual_end_y]} ]]; then
                        visual_end_x=${#content[visual_end_y]}
                    fi
                fi
                ;;
            "k")
                if [[ $visual_end_y -gt 0 ]]; then
                    ((visual_end_y--))
                    if [[ $visual_end_x -gt ${#content[visual_end_y]} ]]; then
                        visual_end_x=${#content[visual_end_y]}
                    fi
                fi
                ;;
            "w")
                # Переход к следующему слову в visual mode
                local temp_x=$visual_end_x
                local temp_y=$visual_end_y
                
                # Сохраняем текущую позицию курсора
                insertx=$temp_x
                inserty=$temp_y
                
                # Вызываем функцию next_word для обновления позиции
                next_word
                
                # Обновляем конечную позицию выделения
                visual_end_x=$insertx
                visual_end_y=$inserty
                ;;
            "b")
                # Переход к предыдущему слову в visual mode
                local temp_x=$visual_end_x
                local temp_y=$visual_end_y
                
                # Сохраняем текущую позицию курсора
                insertx=$temp_x
                inserty=$temp_y
                
                # Вызываем функцию prev_word для обновления позиции
                prev_word
                
                # Обновляем конечную позицию выделения
                visual_end_x=$insertx
                visual_end_y=$inserty
                ;;
            "0")
                # Начало строки в visual mode
                visual_end_x=0
                ;;
            "$")
                # Конец строки в visual mode
                if [[ $visual_end_y -lt $lineCount ]]; then
                    visual_end_x=${#content[visual_end_y]}
                fi
                ;;
            "f")
                # Поиск символа вперед в visual mode
                local temp_x=$visual_end_x
                local temp_y=$visual_end_y
                
                insertx=$temp_x
                inserty=$temp_y
                find_char_forward
                
                visual_end_x=$insertx
                visual_end_y=$inserty
                ;;
            "F")
                # Поиск символа назад в visual mode
                local temp_x=$visual_end_x
                local temp_y=$visual_end_y
                
                insertx=$temp_x
                inserty=$temp_y
                find_char_backward
                
                visual_end_x=$insertx
                visual_end_y=$inserty
                ;;
            "t")
                # Поиск до символа вперед в visual mode
                local temp_x=$visual_end_x
                local temp_y=$visual_end_y
                
                insertx=$temp_x
                inserty=$temp_y
                find_till_char_forward
                
                visual_end_x=$insertx
                visual_end_y=$inserty
                ;;
            "T")
                # Поиск до символа назад в visual mode
                local temp_x=$visual_end_x
                local temp_y=$visual_end_y
                
                insertx=$temp_x
                inserty=$temp_y
                find_till_char_backward
                
                visual_end_x=$insertx
                visual_end_y=$inserty
                ;;
            "g")
                # Переход к строке в visual mode
                local temp_x=$visual_end_x
                local temp_y=$visual_end_y
                
                insertx=$temp_x
                inserty=$temp_y
                goto_line
                
                visual_end_x=$insertx
                visual_end_y=$inserty
                ;;
            "G")
                # Переход в конец файла в visual mode
                local temp_x=$visual_end_x
                local temp_y=$visual_end_y
                
                insertx=$temp_x
                inserty=$temp_y
                goto_end
                
                visual_end_x=$insertx
                visual_end_y=$inserty
                ;;
            "d")
                # Удаление выделенного текста
                delete_selected_text "$visual_start_y" "$visual_start_x" "$visual_end_y" "$visual_end_x"
                visual_mode=0
                # Устанавливаем курсор в начало выделения
                inserty=$visual_start_y
                insertx=$visual_start_x
                ;;
            ":")
                # Команда с выделенным текстом
                local selected_text=$(get_selected_text "$visual_start_y" "$visual_start_x" "$visual_end_y" "$visual_end_x")
                read -p ":" cmd
                if [[ -n "$cmd" ]]; then
                    process_command_with_selection "$cmd" "$selected_text"
                    read -n1 -p "Нажмите любую клавишу для продолжения..."
                fi
                visual_mode=0
                ;;
        esac
        
        # Обновляем позицию курсора для отображения
        inserty=$visual_end_y
        insertx=$visual_end_x
    done
    
    # Обновляем позицию курсора
    inserty=$visual_end_y
    insertx=$visual_end_x
}

process_command_with_selection() {
    local cmd="$1"
    local selected_text="$2"
    
    # Выполняем команду с выделенным текстом
    if [[ -n "$cmd" ]]; then
        echo "$selected_text" | eval "$cmd" 2>/dev/null || echo "Ошибка выполнения команды: $cmd"
    fi
}

q() {
	exit;
}

w() {
	saveFile "$original_file"
}

wq() {
	saveFile "$original_file"
	exit;
}

# Режим команд
commandMode() {
    read -p ":" cmd
	eval "$cmd" 2>/dev/null || echo "Ошибка выполнения команды: $cmd"
	read -n1 -p "Нажмите любую клавишу для продолжения..."
}

# Создание новой строки ниже (как o в Vim)
create_line_below() {
    save_state
    insert_line_after "$inserty"
    # Переходим на новую строку и включаем режим вставки
    ((inserty++))
    insertx=0
    insertMode "normal"
}

# Создание новой строки выше (как O в Vim)
create_line_above() {
    save_state
    insert_line_before "$inserty"
    # Переходим на новую строку и включаем режим вставки
    insertx=0
    insertMode "normal"
}

# Переход в начало строки
goto_line_begin() {
    insertx=0
}

# Переход в конец строки
goto_line_end() {
    if [[ $lineCount -gt 0 ]]; then
        current_string="${content[inserty]}"
        insertx=${#current_string}
    else
        insertx=0
    fi
}

# Создание строки ниже (в нормальном режиме)
create_line_below_normal() {
    save_state
    insert_line_after "$inserty"
    # Остаемся на текущей строке
}

# Создание строки выше (в нормальном режиме)
create_line_above_normal() {
    save_state
    insert_line_before "$inserty"
    # Переходим на новую строку
    ((inserty++))
}

# Основной цикл редактора
main() {
    original_file="$1"
    openFile "$original_file" || return

    startLine=0
    linesPerPage=$(($(tput lines) - 6))
    norewrite=0

    while true; do
        load_config "$START_ITER_CONFIG"

        if [[ $norewrite -eq 0 ]]; then
            rewrite
        fi
        norewrite=0

        read -rsn1 input

        load_config "$END_ITER_CONFIG"

        # Обработка ввода
        case "$input" in
            "q") 
                echo "Используйте :q для выхода"
                sleep 1
                ;;
            "J") 
                ((startLine++))
                if [[ $startLine -ge $lineCount ]]; then
                    startLine=$((lineCount - 1))
                fi
                ;;
            "K") 
                if [[ $startLine -gt 0 ]]; then 
                    ((startLine--))
                fi
                ;;
            ":") commandMode ;;
            "d") 
                echo -n "Диапазон для удаления: "
                read range
                if [[ -n "$range" ]]; then
                    delete_lines "$range"
                fi
                ;;
            "v") visualMode ;;
            "u") undo ;;
            $'\x12') redo ;; # Ctrl+R для redo
            "h") 
                if [[ $insertx -gt 0 ]]; then 
                    ((insertx--))
                elif [[ $inserty -gt 0 ]]; then
                    # Переход на предыдущую строку
                    ((inserty--))
                    current_string="${content[inserty]}"
                    insertx=${#current_string}
                fi
                ;;
            "l") 
                if [[ $lineCount -gt 0 ]]; then
                    if [[ $current_string_length -gt $insertx ]]; then 
                        ((insertx++))
                    elif [[ $inserty -lt $((lineCount - 1)) ]]; then
                        # Переход на следующую строку
                        ((inserty++))
                        insertx=0
                        current_string="${content[inserty]}"
                        current_string_length=${#current_string}
                    fi
                fi
                ;;
            "j") 
                if [[ $inserty -lt $((lineCount - 1)) ]]; then 
                    ((inserty++))
                    if [[ $lineCount -gt 0 ]]; then
                        current_string="${content[inserty]}"
                        current_string_length=${#current_string}
                        if [[ $current_string_length -lt $insertx ]]; then
                            insertx=$current_string_length
                        fi
                    fi
                    adjust_scroll_to_cursor
                fi
                ;;
            "k") 
                if [[ $inserty -gt 0 ]]; then 
                    ((inserty--))
                    if [[ $lineCount -gt 0 ]]; then
                        current_string="${content[inserty]}"
                        current_string_length=${#current_string}
                        if [[ $current_string_length -lt $insertx ]]; then
                            insertx=$current_string_length
                        fi
                    fi
                    adjust_scroll_to_cursor
                fi
                ;;
            "i") insertMode "normal" ;;
            "I") insertMode "begin" ;;   # В начале строки
            "a") insertMode "after" ;;    # После курсора
            "A") insertMode "end" ;;      # В конце строки
            "D") removeModer ;;
            "o") create_line_below ;;     # Новая строка ниже + insert mode
            "O") create_line_above ;;     # Новая строка выше + insert mode
            "0") goto_line_begin ;;       # Начало строки
            "$") goto_line_end ;;         # Конец строки
            "+") create_line_below_normal ;; # Новая строка ниже (normal mode)
            "-") create_line_above_normal ;; # Новая строка выше (normal mode)
            "f") find_char_forward ;;     # Поиск символа вперед
            "F") find_char_backward ;;    # Поиск символа назад
            "t") find_till_char_forward ;; # Поиск до символа вперед
            "T") find_till_char_backward ;; # Поиск до символа назад
            "g") goto_line ;;             # Переход к строке
            "G") goto_end ;;              # Переход в конец файла
            "w") next_word ;;             # Следующее слово
            "b") prev_word ;;             # Предыдущее слово
        esac

        norewrite=0
    done
}

# Основная функция
if [[ $# -lt 1 ]]; then
    echo "Использование: $0 <имя_файла>"
    echo "Пример: $0 example.txt"
    exit 1
fi

# Проверка и создание файла
if [[ ! -f "$1" ]]; then
    echo "Файл '$1' не найден."
    read -rsn1 -p "Создать новый файл? (y/N): " input
    echo
    if [[ $input == "y" || $input == "Y" ]]; then
        touch "$1" || {
            echo "Ошибка: не удалось создать файл '$1'"
            exit 1
        }
    else
        exit 0
    fi
fi

original_file="$1"

# Загрузка конфигураций
load_config "$START_CONFIG"
load_config "$PREMAIN_CONFIG"

# Запуск редактора
main "$original_file"

echo "Редактор завершил работу."
exit 0
